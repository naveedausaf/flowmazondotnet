name: Release to Production
concurrency: release-to-prod-pipeline
on:
  push:
    branches:
      - main

jobs:
  chromatic:
    uses: "./.github/workflows/chromatic.yml"
    with:
      failOnChanges: true
      workingDir: ./flowmazonfrontend
    secrets:
      CHROMATIC_PROJECT_TOKEN: ${{ secrets.CHROMATIC_PROJECT_TOKEN }}
  create-release:
    environment:
      name: Production
    permissions:
      contents: write # to be able to publish a GitHub release
      issues: write # to be able to comment on released issues
      pull-requests: write # to be able to comment on released pull requests
    runs-on: ubuntu-24.04
    name: Create Release
    outputs:
      released: ${{ env.RELEASED }}
      newVersion: ${{ env.NEW_VERSION }}
    steps:
      - uses: actions/checkout@v4
        name: Checkout code
        id: checkout
        with:
          # This is needed for semantic-release to work,
          # giving it access to the full git history so it
          # can compute the next version and generate release notes.
          fetch-depth: 0

      - name: Install Package Dependencies
        # needed for both commitlint and semantic-release to work
        run: npm ci

      - name: Lint commits on main since last version tag
        run: |

          # Find latest version tag 
          # Starts with 'v' followed by a digit
          lasttag=$(git describe --tags --abbrev=0 --match="v[0-9]*" 2>/dev/null) \
            || echo "no version tag found, will only lint commit message of last commit"

          # Compute arguments to commitlint
          if [ "$lasttag" == "" ]; then

          # A version tag was not found (i.e. semantic-release has yet
          # to run successfully for the first time on current branch).
          # So only parse the last/latest commit.
            clargs="--last"

          else

          # latest version tag (that was found) should be mapped to
          # SHA of the commit bearing the tag. This should be --from
          # argument to commitlint (this is excluded when commitlint
          # run) and HEAD should be the --to argument (this would
          # be included when commitlint runs)
            echo "latest version tag is $lasttag, will lint messages of all commits forward of this up to HEAD..."
            clargs="--from=$(git rev-parse $lasttag) --to=HEAD"
            
          fi

          # Run commitlint with computed arguments
          # npx -- commitlint --verbose $clargs
      - name: Create GitHub release
        id: semanticrelease
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "RELEASED=0" >> $GITHUB_ENV
          npm audit signatures
          npm run release

      # Instead of a separate job, you can have steps to
      # deploy in the same job.
      # However, each would need to be made conditional on
      # env.RELEASED variable (set during npm run release)
      # being 1. For example:
      #
      # - name: Deploy Step 1
      #   id: deploystep1
      #   if: ${{ env.RELEASED == 1 }}

  api-unittests:
    name: API Unit Tests
    runs-on: ubuntu-24.04
    needs: create-release
    environment:
      name: Production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x
      - name: Restore dependencies
        working-directory: ./flowmazonbackend/flowmazonapi.UnitTests
        run: dotnet restore
      - name: Run unit tests with coverage
        working-directory: ./flowmazonbackend/flowmazonapi.UnitTests
        # Generating test results file (test_results.xml, not the cobertura format coverage file which is separate) in JUnit format because this is the only format CodeCov currently accepts test results in for its experimental test analytics feature (this is separate to its code coverage feature).
        # In order for dotnet test to be able to use test run report in this format, we need to add reference to `JunitXml.TestLogger` in the test project (not in the project under test), as described here:
        # https://github.com/spekt/junit.testlogger
        #
        # We also upload the test_results.xml file as a Check (which appears in the Checks tab of the pull request) using dorny/test-reporter action as the CodeCov Test Results Analytics feature is still experimental.
        run: |
          dotnet test --configuration Release \
            --logger "junit;LogFileName=test_results.xml" \
            --results-directory ./TestResults \
            --collect:"XPlat Code Coverage"
      - name: Publish test report to PR Checks
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: API Unit Tests
          path: flowmazonbackend/flowmazonapi.UnitTests/TestResults/**/test_results.xml
          # java-junit reporter is experimental in this action. If this doesn't work properly then reporter should be jest-junit.
          # Bear in mind though that to use jest-junit, you need to surround the contents of this xml file with a <testsuites> element which has a `time` attribute. See my wiki for details.

      #     reporter: java-junit
      #     fail-on-error: false
      - name: Upload coverage to Codecov
        if: always()
        uses: codecov/codecov-action@v5
        with:
          files: flowmazonbackend/flowmazonapi.UnitTests/TestResults/**/coverage.cobertura.xml
          fail_ci_if_error: true
          # flags: api-unittests
          name: api-unittests
          token: ${{ secrets.CODECOV_TOKEN }}
          verbose: true
  migrate-db:
    environment:
      name: Production
    needs: [create-release, chromatic, api-unittests]
    if: ${{ needs.create-release.outputs.released == 1}}
    name: Migrate Database
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install psql client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Run migrations
        env:
          MIGRATIONS_DIR: ./flowmazonbackend/flowmazonapi/MigrationScripts
        run: |
          for f in "$MIGRATIONS_DIR"/*.sql; do
            filename=$(basename "$f")
            echo "Applying migration $filename"
            psql "${{secrets.TF_MANAGED_PSQL_OWNER_CONNECTIONSTRING}}" -f "$f"
          done
  deploy-backend:
    environment:
      name: Production
    needs: [create-release, migrate-db]
    if: ${{ needs.create-release.outputs.released == 1}}
    name: Deploy API to Azure
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Print version to console
        run: |
          echo "New Version Number is: ${{ needs.create-release.outputs.newVersion }}"
      - name: Login to Azure
        uses: azure/login@v1
        with:
          # The referenced secret AZURE_CREDENTIALS contains
          # JSON with client id, client secret, tenant id and
          # subscription id of the service principal which
          # has AcrPush permission on the subscrpition or at least
          # on the ACR instance to which it will push in this job
          # within the subscription whose subscription id is provided.
          #
          # Format of the JSON is:
          # {
          #     "clientId": "<visible on service principal when you create it in portal>",
          #     "clientSecret": "<in portal you have to create it after creating the service principal>",
          #     "subscriptionId": "<subscription id of the subscription on which you have given AcrPush permission to the service principal>",
          #     "tenantId": "<visible on service principal when you create it in portal>"
          # }
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: |
          az acr login --name ${{ vars.ACR_NAME }}

      - name: Build Docker image
        run: |
          cd ./flowmazonbackend
          docker build -t ${{ vars.ACR_NAME }}.azurecr.io/${{ vars.IMAGE_REPOSITORY }}:${{ needs.create-release.outputs.newVersion }} .

      - name: Push Docker image
        run: |
          docker push ${{ vars.ACR_NAME }}.azurecr.io/${{ vars.IMAGE_REPOSITORY }}:${{ needs.create-release.outputs.newVersion }}

      # We need to run terraform apply on prod-api workspace
      # because Terraform resource for ACA app must deploy a container
      # also (otherwise the whole wrorkspace would fail to apply).
      #
      # Therefore we use the workspace to deploy the latest version
      # and later would be doing Blue-Green with it. The ACA resource
      # in the Terraform workspace would pull the container image with
      # the specified version upon terraform apply.
      #
      # As terraform apply runs on HCP Terraform's clean runner machine,
      # we don't need to create a separate job to run terraform apply.
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3
        with:
          # cli_config_credentials_hostname parameter default
          # to app.terraform.io which is what we want
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Run terraform apply on prod-api workspace
        run: |
          cd .iac/workspaces/prod-api
          terraform init
          terraform apply -auto-approve -var="image_tag=${{ needs.create-release.outputs.newVersion }}"

  # this job is based on this Vercel sample:
  # https://github.com/vercel/examples/tree/main/ci-cd/github-actions
  deploy-frontend-to-vercel:
    name: Deploy Next.js frontend to Vercel
    runs-on: ubuntu-24.04
    environment:
      name: Production
      #url: ${{ steps.deploy-artifacts.outputs.previewUrl }}
      url: https://www.efast.uk
    env:
      VERCEL_API_TOKEN: ${{ secrets.VERCEL_API_TOKEN }}
      # VERCEL_ORG_ID is the vercel_team_id variable that
      # we supply to Terraform prod workspace that creates
      # the project whose project is in VERCEL_PROJECT_ID,
      # as this Vercel link says (and it works too):
      # https://vercel.com/docs/git/vercel-for-azure-pipelines#value-of-vercelorgid
      #
      # Therefore I name the secret VERCEL_TEAM_ID also
      VERCEL_ORG_ID: ${{ secrets.VERCEL_TEAM_ID }}
      # VERCEL_PORJECT_ID is the other required environment
      # variable for Vercel CLI operations in this job. This
      # will be loaded dynamically from Terraform workspace
      # that creates the project and outputs its id in an
      # output variable.
      VERCEL_PROJECT_ID: ${{ secrets.TF_MANAGED_VERCEL_PROJECT_ID }}
    needs: [create-release, deploy-backend]
    if: ${{ needs.create-release.outputs.released == 1}}
    steps:
      - uses: actions/checkout@v4
      - name: Print version to console
        run: |
          echo "New Version Number is: ${{ needs.create-release.outputs.newVersion }}"
      - name: Update Version Number in package.json
        working-directory: ./flowmazonfrontend
        run: npm --no-git-tag-version version ${{ needs.create-release.outputs.newVersion }}
      - name: Install Vercel CLI
        working-directory: ./flowmazonfrontend
        run: npm install --global vercel@latest

      - name: Pull Vercel Environment Information
        working-directory: ./flowmazonfrontend
        run: vercel pull --yes --environment=production --token=${{ secrets.VERCEL_API_TOKEN }}
        # USing --prod with vercel build below
        # means the build would use environment variables
        # from Production environment in Vercel project
        # which is what we want. Otherwise it would have
        # used Preview environment variables
      - name: Build Project Artifacts
        working-directory: ./flowmazonfrontend
        run: vercel build --prod --token=${{ secrets.VERCEL_API_TOKEN }}
        env:
          NEXT_PUBLIC_BACKEND_URL: ${{vars.NEXT_PUBLIC_BACKEND_URL}}
          NEXT_PUBLIC_OTEL_ENVIRONMENT: ${{vars.NEXT_PUBLIC_OTEL_ENVIRONMENT}}
          NEXT_PUBLIC_FARO_URL: ${{secrets.TF_MANAGED_FARO_URL}}
          NEXT_PUBLIC_FARO_SERVICE_NAME: ${{secrets.NEXT_PUBLIC_FARO_SERVICE_NAME}}
      - name: Deploy Project Artifacts to Vercel
        working-directory: ./flowmazonfrontend
        id: deploy-artifacts
        run: |
          previewUrl=$(vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_API_TOKEN }})
          echo "previewUrl=$previewUrl" >> "$GITHUB_OUTPUT"
